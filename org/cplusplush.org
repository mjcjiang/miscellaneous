* Low level programming
** Implement bit array using c
#+NAME: bit array write in c
#+BEGIN_SRC cpp
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#define BITS_PER_INT (sizeof(int) * 8)

void setBit(int *arr, int index) {
    int arrIndex = index / BITS_PER_INT;
    int bitIndex = index % BITS_PER_INT;
    arr[arrIndex] |= (1 << bitIndex);
}

void clearBit(int *arr, int index) {
    int arrIndex = index / BITS_PER_INT;
    int bitIndex = index % BITS_PER_INT;
    arr[arrIndex] &= ~(1 << bitIndex);
}

bool getBit(int *arr, int index) {
    int arrIndex = index / BITS_PER_INT;
    int bitIndex = index % BITS_PER_INT;
    return (arr[arrIndex] & (1 << bitIndex)) != 0;
}

int main(int argc, char *argv[])
{
    const int SIZE = 20;
    const int ARR_LEN = (SIZE + BITS_PER_INT - 1) / BITS_PER_INT;
    int bitArray[ARR_LEN];
    memset(bitArray, 0, ARR_LEN * sizeof(int));

    setBit(bitArray, 2);
    setBit(bitArray, 5);
    setBit(bitArray, 8);

    int i = 0;
    for(i = 0; i < SIZE; i++) {
        if (getBit(bitArray, i))
            printf("%d\n", i);
    }
    
    return 0;
}
#+END_SRC
* Multi Threading
** use std::lock avoid dead lock
#+BEGIN_SRC c++
#include <mutex>
#include <thread>
#include <iostream>
#include <vector>
#include <functional>
#include <chrono>
#include <string>

struct Employee {
    Employee(std::string id) : id(id) {}
    std::string id;
    std::vector<std::string> lunch_partners;
    std::mutex m;
    std::string output() const
    {
        std::string ret = "Employee " + id + " has lunch partners: ";
        for( const auto& partner : lunch_partners )
            ret += partner + " ";
        return ret;
    }
};

void send_mail(Employee &, Employee &)
{
    // simulate a time-consuming messaging operation
    std::this_thread::sleep_for(std::chrono::seconds(1));
}

void assign_lunch_partner(Employee &e1, Employee &e2)
{
    static std::mutex io_mutex;
    {
        std::lock_guard<std::mutex> lk(io_mutex);
        std::cout << e1.id << " and " << e2.id << " are waiting for locks" << std::endl;
    }

    // use std::lock to acquire two locks without worrying about 
    // other calls to assign_lunch_partner deadlocking us
    {
        std::lock(e1.m, e2.m);
        std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);
        std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);
// Equivalent code (if unique_locks are needed, e.g. for condition variables)
//        std::unique_lock<std::mutex> lk1(e1.m, std::defer_lock);
//        std::unique_lock<std::mutex> lk2(e2.m, std::defer_lock);
//        std::lock(lk1, lk2);
// Superior solution available in C++17
//        std::scoped_lock lk(e1.m, e2.m);
        {
            std::lock_guard<std::mutex> lk(io_mutex);
            std::cout << e1.id << " and " << e2.id << " got locks" << std::endl;
        }
        e1.lunch_partners.push_back(e2.id);
        e2.lunch_partners.push_back(e1.id);
    }
    send_mail(e1, e2);
    send_mail(e2, e1);
}

int main()
{
    Employee alice("alice"), bob("bob"), christina("christina"), dave("dave");

    // assign in parallel threads because mailing users about lunch assignments
    // takes a long time
    std::vector<std::thread> threads;
    threads.emplace_back(assign_lunch_partner, std::ref(alice), std::ref(bob));
    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(bob));
    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(alice));
    threads.emplace_back(assign_lunch_partner, std::ref(dave), std::ref(bob));

    for (auto &thread : threads)
        thread.join();
    std::cout << alice.output() << '\n'  << bob.output() << '\n'
              << christina.output() << '\n' << dave.output() << '\n';
}
#+END_SRC
** use std::scoped_lock avoid dead lock
#+BEGIN_SRC
#include <chrono>
#include <functional>
#include <iostream>
#include <mutex>
#include <string>
#include <thread>
#include <vector>
using namespace std::chrono_literals;
 
struct Employee
{
    std::vector<std::string> lunch_partners;
    std::string id;
    std::mutex m;
    Employee(std::string id) : id(id) {}
    std::string partners() const
    {
        std::string ret = "Employee " + id + " has lunch partners: ";
        for (const auto& partner : lunch_partners)
            ret += partner + " ";
        return ret;
    }
};
 
void send_mail(Employee &, Employee &)
{
    // simulate a time-consuming messaging operation
    std::this_thread::sleep_for(1s);
}
 
void assign_lunch_partner(Employee &e1, Employee &e2)
{
    static std::mutex io_mutex;
    {
        std::lock_guard<std::mutex> lk(io_mutex);
        std::cout << e1.id << " and " << e2.id << " are waiting for locks" << std::endl;
    }
 
    {
        // use std::scoped_lock to acquire two locks without worrying about
        // other calls to assign_lunch_partner deadlocking us
        // and it also provides a convenient RAII-style mechanism
 
        std::scoped_lock lock(e1.m, e2.m);
 
        // Equivalent code 1 (using std::lock and std::lock_guard)
        // std::lock(e1.m, e2.m);
        // std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);
        // std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);
 
        // Equivalent code 2 (if unique_locks are needed, e.g. for condition variables)
        // std::unique_lock<std::mutex> lk1(e1.m, std::defer_lock);
        // std::unique_lock<std::mutex> lk2(e2.m, std::defer_lock);
        // std::lock(lk1, lk2);
        {
            std::lock_guard<std::mutex> lk(io_mutex);
            std::cout << e1.id << " and " << e2.id << " got locks" << std::endl;
        }
        e1.lunch_partners.push_back(e2.id);
        e2.lunch_partners.push_back(e1.id);
    }
 
    send_mail(e1, e2);
    send_mail(e2, e1);
}
 
int main()
{
    Employee alice("Alice"), bob("Bob"), christina("Christina"), dave("Dave");
 
    // assign in parallel threads because mailing users about lunch assignments
    // takes a long time
    std::vector<std::thread> threads;
    threads.emplace_back(assign_lunch_partner, std::ref(alice), std::ref(bob));
    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(bob));
    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(alice));
    threads.emplace_back(assign_lunch_partner, std::ref(dave), std::ref(bob));
 
    for (auto &thread : threads)
        thread.join();
    std::cout << alice.partners() << '\n'  << bob.partners() << '\n'
              << christina.partners() << '\n' << dave.partners() << '\n';
}
#+END_SRC
** mutex hierachical
   https://stackoverflow.com/questions/5340928/utilities-for-creating-a-lock-hierarchy
#+BEGIN_SRC c++
#include <mutex>
#include <thread>
#include <chrono>
#include <climits>
#include <iostream>

class hierarch_mutex {
public:
    explicit hierarch_mutex(unsigned long val)
        : hierarch_val(val), prev_hierach_val(0) {}

    void lock() {
        check_for_hierarch_violation();
        mutex_.lock();
        update_hierarch_value();
    }

    void unlock() {
        this_thread_hierarch_val = prev_hierach_val;
        mutex_.unlock();
    }

    bool try_lock() {
        check_for_hierarch_violation();
        if(!mutex_.try_lock())
            return false;
        update_hierarch_value();
        return true;
    }
private:
    void check_for_hierarch_violation() {
        if (this_thread_hierarch_val <= hierarch_val) {
            throw std::logic_error("mutex hierarch violated");
        }
    }

    void update_hierarch_value() {
        prev_hierach_val = this_thread_hierarch_val;
        this_thread_hierarch_val = hierarch_val;
    }
private:
    std::mutex mutex_;
    unsigned long const hierarch_val;
    unsigned long prev_hierach_val;
    static thread_local unsigned long this_thread_hierarch_val;
};

thread_local unsigned long hierarch_mutex::this_thread_hierarch_val(ULONG_MAX);

hierarch_mutex high_level_mutex(10000);
hierarch_mutex low_level_mutex(5000);
hierarch_mutex other_level_mutex(100);

int do_low_level_staff() {
    std::this_thread::sleep_for(std::chrono::seconds(10));
    std::cout << "low staff finished..." << std::endl;
    return 10;
}

int low_level_func() {
    std::lock_guard<hierarch_mutex> lk(low_level_mutex);
    return do_low_level_staff();
}

void do_high_level_staff(int some_param) {
    std::this_thread::sleep_for(std::chrono::seconds(10));
    std::cout << "high staff finished..." << std::endl;
}

void high_level_func() {
    std::lock_guard<hierarch_mutex> lk(high_level_mutex);
    do_high_level_staff(low_level_func());
}

void do_other_staff() {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "other staff finished..." << std::endl;
}

void other_staff_func() {
    std::lock_guard<hierarch_mutex> lk(other_level_mutex);
    high_level_func();
    do_other_staff();
}

void thread_a() {
    high_level_func();
}

void thread_b() {
    high_level_func();
}

void thread_c() {
    other_staff_func();
}

int main(int argc, char *argv[])
{
    std::thread a(thread_a);
    std::thread b(thread_b);
    std::thread c(thread_c);
    a.join();
    b.join();
    c.join();
    return 0;
}
#+END_SRC
